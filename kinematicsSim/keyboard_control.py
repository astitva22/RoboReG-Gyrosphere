import pybullet as pb
import pybullet_data
import time
import numpy as np 
import os

def Calc_angVels(desired_angVel):                #takes the desired angle of steering and returns the
    A = np.array([[     2.,      0., 0.353627], #driving angular velocity of each wheel in form
                  [    -1.,  1.7319, 0.353521], #np.array([[w1],[w2],[w3]]) (column matrix)
                  [    -1., -1.7319, 0.353521]])
    calc_angvel = np.dot(A,desired_angVel)
    return calc_angvel

physicsClient = pb.connect(pb.GUI)
pb.setAdditionalSearchPath(pybullet_data.getDataPath())
pb.setGravity(0,0,-9.8)

parent_dir = os.path.dirname(__file__)

pb.loadURDF("plane.urdf")
bot = pb.loadURDF(parent_dir+"/urdfs/outershell.urdf",[0,0,2.5])
 
fwd = 0
side = 0   
motor_torque = 50  
while(True):
    keys = pb.getKeyboardEvents()
    for k,v in keys.items():
        if(k == pb.B3G_UP_ARROW and (v & pb.KEY_IS_DOWN)):
            fwd = -0.1*motor_torque
        if(k == pb.B3G_DOWN_ARROW and (v & pb.KEY_IS_DOWN)):
            fwd = 0.1*motor_torque
        if(k == pb.B3G_LEFT_ARROW and (v & pb.KEY_IS_DOWN)):
            side = 0.1*motor_torque
        if(k == pb.B3G_RIGHT_ARROW and (v & pb.KEY_IS_DOWN)):
            side = -0.1*motor_torque
        if(v & pb.KEY_WAS_RELEASED):
            fwd = 0
            side = 0
    pb.stepSimulation()
    time.sleep(1./240.)

    desired_ang_vel = np.array([[side],
                                 [fwd],
                                 [0]])
    angVels = Calc_angVels(desired_ang_vel)
    #print(angVel) 
    w1 = angVels[0][0]
    w2 = angVels[1][0]
    w3 = angVels[2][0]
    #print(angVel)
    #print(pb.getBasePositionAndOrientation(bot))
            
    T1 = np.array([ 0.3333*w1,      0*w1,0.9428*w1]) #Torque generated by motor 1
    T2 = np.array([-0.1667*w2, 0.2887*w2,0.9428*w2]) #Torque generated by motor 2
    T3 = np.array([-0.1667*w3,-0.2887*w3,0.9428*w3]) #Torque generated by motor 3
    
    #print(T1+T2+T3)
    print(pb.getBaseVelocity(bot)[1])

    pb.applyExternalTorque(bot,-1,T1,pb.LINK_FRAME) #Applying Torque generated by motor 1
    pb.applyExternalTorque(bot,-1,T2,pb.LINK_FRAME) #Applying Torque generated by motor 2
    pb.applyExternalTorque(bot,-1,T3,pb.LINK_FRAME) #Applying Torque generated by motor 3   

pb.close()   
#cv2.destroyAllWindows()