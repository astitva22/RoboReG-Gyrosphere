import numpy as np
import pybullet as p
import pybullet_data
import controlpy
import os
import time
import matplotlib.pyplot as plt

def Calc_components(desired_angVel):                    # takes the desired angle of steering and returns the
    R_matrix = np.array([[     2.,      0., 0.353627],  # driving torque of each wheel in form
                         [    -1.,  1.7319, 0.353521],  # np.array([[t1],[t2],[t3]]) (column matrix)
                         [    -1., -1.7319, 0.353521]])
    components = np.dot(R_matrix,desired_angVel)
    return components

R = 1.0  #radius
I = 0.66666667 #Moment of inertia
M = 1.0 #mass

A = np.zeros((2,2))
B = np.array([[R/I  ,   0.],
              [0.  ,   R/I]])

class LQR_controller:
    def __init__(self):
        self.Q = np.array([[  1000.,     0.],
                           [     0.,  1000.]] )

        self.R = np.array([[1000.,     0.],
                           [   0.,  1000.]])
        self.K,self.S,self.e = controlpy.synthesis.controller_lqr(A,B,self.Q,self.R)                   

    def callback(self,data,target):
        #self.K,self.S,self.e = controlpy.synthesis.controller_lqr(A,B,self.Q,self.R)
        X = data-target
        u_t = -np.matmul(self.K,X)
        X_dot = (np.matmul(A,X)+np.matmul(B,u_t))
        return X_dot

def synthesizeData(robot):
    pos = p.getBasePositionAndOrientation(robot)[0]
    vel = p.getBaseVelocity(robot)[0]
    data = np.array([[pos[0]],
                     [pos[1]],
                     [vel[0]],
                     [vel[1]]])
    return data

if __name__ == '__main__':
    
    parent_dir = os.path.dirname(__file__)

    physics_client = p.connect(p.GUI)
    p.setAdditionalSearchPath(pybullet_data.getDataPath())
    p.setGravity(0,0,-9.8)

    plane = p.loadURDF("plane.urdf")
    bot = p.loadURDF(parent_dir+"/outershell.urdf",[0,0,2.5])

    my_controller = LQR_controller()

    target_vel = 3
    target_x,target_y = 0,0
    
    bot_positions_x,bot_positions_y = list(),list()

    for i in range(5000):
        data = synthesizeData(bot)

        x = data[0][0]/5
        desired_vel = np.array([[target_vel/np.sqrt(1+np.cos(x)**2)],              # For now the path has been hard
                                [target_vel*np.cos(x)/np.sqrt(1+np.cos(x)**2)]])   # coded as sine curve                     

        x_dot =  my_controller.callback(
                data[2:],
                target = desired_vel
            ).ravel()
        
        if(np.floor((10*time.time()))%5 == 0):
            target_x += 0.1
            target_y = np.sin(target_x) 
            
            bot_positions_x.append(data[0][0])
            bot_positions_y.append(data[1][0])

        print(data)
        print(desired_vel)
        print(x_dot)
        
        trq_y = I/R*x_dot[0]
        trq_x = I/R*x_dot[1]

        desired_torque = np.array([[-trq_x],
                                   [ trq_y],
                                   [    0.]])

        t1,t2,t3 = Calc_components(desired_torque).ravel() #t1,t2,t3 are magnitudes of torques generated by motors
       
        T1 = np.array([ 0.3333*t1,      0*t1,0.9428*t1]) #Torque generated by motor 1 in vector form
        T2 = np.array([-0.1667*t2, 0.2887*t2,0.9428*t2]) #Torque generated by motor 2 in vector form
        T3 = np.array([-0.1667*t3,-0.2887*t3,0.9428*t3]) #Torque generated by motor 3 in vector form
        
        p.applyExternalTorque(bot,-1,T1,p.WORLD_FRAME) #Applying Torque generated by motor 1
        p.applyExternalTorque(bot,-1,T2,p.WORLD_FRAME) #Applying Torque generated by motor 2
        p.applyExternalTorque(bot,-1,T3,p.WORLD_FRAME) #Applying Torque generated by motor 3 
        
        p.stepSimulation()
        time.sleep(1./240.) 

    plt.plot(bot_positions_x,bot_positions_y)
    plt.show()
    p.disconnect()